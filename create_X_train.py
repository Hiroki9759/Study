"""
Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zL1tvO_AKuqThFtl1KN7QsC5Zz6c6gj6
"""

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x magic
#!pip install music21
#!pip install keras-gcn
#!pip install hyperas==0.4.1
from __future__ import print_function,division, absolute_import
import os
import glob
import csv
import math
import time
import h5py
import numpy as np
import tensorflow as tf
import pretty_midi
from music21 import converter, instrument, note, chord, stream
import keras
from keras import Sequential , layers, activations, initializers, constraints, regularizers
from keras.engine import Layer
from keras.layers.core import Reshape, Dense, Dropout,Activation,Flatten
from keras.layers import Input,Dropout,RepeatVector, Dense, TimeDistributed,Embedding,LSTM, CuDNNLSTM,Flatten,concatenate,Lambda,Conv2D
from keras.optimizers import Adam,RMSprop
from keras.layers.advanced_activations import LeakyReLU
from keras.layers.normalization import *
from keras.activations import *
from keras.optimizers import *
from keras.models import Model, load_model
from keras.regularizers import l2
import keras.backend as K
import scipy.sparse as sp
from scipy.sparse.linalg.eigen.arpack import eigsh, ArpackNoConvergence
from keras_gcn import GraphConv
import random
import hyperas
import torch as th
import datetime
import torch.nn as nn
import torch.nn.functional as F
from keras.callbacks import TensorBoard

from tensorflow.nn import sigmoid_cross_entropy_with_logits
from hyperopt import Trials, STATUS_OK, tpe, rand
from hyperas import optim
from hyperas.distributions import choice, uniform
from PIL import Image
import matplotlib.pyplot as plt
midi_dir = 'Chineseinput'
out_dir = 'output'
pitch = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B","C"]
notesize = 64
def pitch_to_note(pitchname):
    for i in range(128):
        if(pitchname == pitch[i%12] + str(int(i/12)-1)):
            return i
        elif(pitchname == pitch[i%12+1] + str(-1*(int(i/12)-1))):
            return i
def note_to_pitch(notee):
    notesize = 64
    notee = np.array(notee)
    print(len(notee))
    k = random.randint(0,len(notee))
    pm = pretty_midi.PrettyMIDI(resolution=220,initial_tempo=120.0)
    instrument = pretty_midi.Instrument(0)
    for j in range(128):
        for i in range(notesize):
            element = notee[k,j,i]
            if(element > 0.09):
                note = pretty_midi.Note(velocity=100,pitch=j,start=i*0.25,end=(i+1)*0.25)
                instrument.notes.append(note)
                pm.instruments.append(instrument)
            # else:
                # print("element<1e-3")
    count = 0
    for note in instrument.notes:
        count += 1
    print(count)
    if(count > 500):
        am = pretty_midi.PrettyMIDI(resolution=220,initial_tempo=120.0)
        instrument = pretty_midi.Instrument(0)
        return am
    else:
        
        print(pm)
        return pm
def parse_midi_files(dir):
    notesize = 64
    files = glob.glob(os.path.join(dir, '*.mid'))
    notes = []
    songs = []
    file_list = np.empty(shape=[128,128,0])
    X_train = []
    A_train = []
    song = np.zeros((128,notesize))
    adjacency = np.zeros((128,128))
    start = time.time()
    for file in files:  
        num = 0
        t = 0
        k = 0
        pre_node = 0
        now_node = 0
        song = np.zeros((128,notesize))
        adjacency = np.zeros((128,128))
        # digree = np.zeros((128,128))
        # laplacian = np.zeros((128,128))
        # rest_adjacency = np.zeros((128,128))
        # rest_digree = np.zeros((128,128))
        # rest_laplacian = np.zeros((128,128))
        print("Parsing %s" % file)
        file_list = file_list.tolist()
        file_list.append(os.path.basename(file))
        file_list = np.array(file_list)
        midi = converter.parse(file)
        
        notes_to_parse = None

        try: # file has instrument parts
            s2 = instrument.partitionByInstrument(midi)
            notes_to_parse = s2.parts[0].recurse() 
            
        except: # file has notes in a flat structure
            notes_to_parse = midi.flat.notes
        print(len(notes_to_parse)//notesize)
        # for element in notes_to_parse:
        for i in range(len(notes_to_parse)//notesize):
            num=0
            for j in range((i-1)*notesize,i*notesize):
                
                if isinstance(j, note.Note):
                    # song[num][pitch_to_note(element.nameWithOctave)] = 1                                                                                                                                 
                    song[pitch_to_note((j%notesize).nameWithOctave)][num]=1
                    now_node = pitch_to_note((j%notesize).nameWithOctave)
                    adjacency[now_node][pre_node] = 1
                    t = pitch_to_note((j%notesize).nameWithOctave)
                    num += 1
                    k=num  
                    pre_node = pitch_to_note((j%notesize).nameWithOctave)
            
                elif isinstance(j,note.Rest):       
                    adjacency[t][num]=1     
                    num+=1
                else:  
                    num+=1 
            A = np.matrix(adjacency)
            X = np.matrix(song)
            X_train.append(X)
            A_train.append(A)
            # elif(num >128):
            #     for j in range (100):
            #         for i in range (128*(j-1),128*j):
            #             if isinstance(element, note.Note):
            #                 song[num][pitch_to_note(element.nameWithOctave)]=1
            #                 now_node = pitch_to_note(element.nameWithOctave)
            #                 adjacency[pre_node][now_node] = 1
            #                 t = pitch_to_note(element.nameWithOctave)
            #                 if(k != num ):
            #                     rest_adjacency[pre_node][now_node]=1
            #                     rest_digree[pre_node][pre_node] += 1
            #                     rest_digree[now_node][now_node] += 1
            #                 num += 1
            #                 k=num  
            #                 pre_node = pitch_to_note(element.nameWithOctave)
            #                 A = np.matrix(adjacency)
            #                 X = np.matrix(song)
            #                 X_train.append(X)
            #                 A_train.append(A)
            #             elif isinstance(element,note.Rest):       
            #                 adjacency[num][t]=1     
            #                 num+=1
            #             else:  
            #                 num+=1
        songs.append(song.tolist())
        notes += song.tolist()
    elapsed_time = time.time() - start
    print ("elapsed_time:{0}".format(elapsed_time) + "[sec]")
    return notes, songs, file_list,A_train,song,X_train

notes, songs, file_list,A_train,song,X_train = parse_midi_files(midi_dir)
print("parse finished")
print(len(X_train))
np.save('output\Chinese_X_train',X_train)
np.save('output\Chinese_A_train',A_train)

#print(X_train[100][10][:])

#X = np.array(X_train)

# np.set_printoptions(threshold=np.inf)

# #note_to_pitch(X_train)
# X_train=np.load('output\classic_X_train.npy')
# A_train=np.load('output\classic_A_train.npy')
# SYM_NORM = True 